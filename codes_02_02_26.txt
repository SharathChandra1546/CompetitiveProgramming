You are given two integers start and goal.
In one operation, you can flip any one bit of start (change 0 to 1 or 1 to 0).
Your task is to find the minimum number of bit flips required to convert start 
into goal.

Input Format:
--------------
Two integers:
Start Goal

Output Format:
----------------
A single integer (minimum number of bit flips)

Sample Input 1:
---------------
10 7

Sample Output 1:
-----------------
3

import java.util.*;
class MinBitFlips{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n1 = sc.nextInt();
        int n2 = sc.nextInt();
        int x = n1^n2;
        int count=0;
        while(x>0){
           if((x&1)==1){
               count++;
           }
           x>>=1;
        }
        System.out.println(count);
    }
}

You are given an array of integers.
A subarray is called nice if no two numbers in it share a common set bit
Your task is to find the length of the longest nice subarray.

Input Format:
----------------
n
array integers

Output format:
----------------
length of longest nice subarray

Sample Input:
-------------
5
1 3 8 48 10

Sample Output:
-------------
3

Explanation:
------------
1  = 00001  
3  = 00011  
8  = 01000  
48 = 110000  
10 = 01010
The longest nice subarray is: [3, 8, 48]
No two numbers share a set bit.
import java.util.*;
class LongestNiceSubarray{
    public static int nice(int[] arr,int n){
        int x= 0;
        int maxLen = 0;
        int left =0;
        for(int i=0;i<n;i++){
            while((x&arr[i])!=0){
                x = x^arr[left];
                left++;
            }
            x = x|arr[i];
            maxLen = Math.max(maxLen,i-left+1);
        }
        return maxLen;
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        System.out.println(nice(arr,n));
    }
}
public static void ele(int n,int[] arr){
        int res=0,left=0,or=0;
        for(int right=0;right<n;right++){
            while((or&arr[right])!=0){
                or^=arr[left];
                left++;
            }
            or=or|arr[right];
            res = Math.max(res,right-left+1);
        }
        System.out.print(res);
        
    }



Given an array of integers where all elements occur twice 
except exactly two elements, which occur only once, 
your task is to find these two non-repeated elements.

You must print the two non-repeating elements in the order they are found.

Input Format
------------
First line contains an integer N — size of the array.
Second line contains N space-separated integers.

Output Format
---------------
Print the two non-repeated integers, separated by space.

Constraints
-----------
2 ≤ N ≤ 10^6
Array will contain exactly two unique elements and all others repeated twice.

Input:
------
8
2 3 7 9 2 3 9 11

Output:
--------
7  11  (OR)
11 7

Explanation:
------------
2,3,9 are repeated twice → ignored
7 and 11 occur once → printed.
-

Given two integers left and right, return the count of numbers in the inclusive 
range [left, right] having a prime number of set bits in their binary
representation.

Recall that the number of set bits an integer has the number of 1's present when
written in binary.

For example, 21 written in binary is 10101, which has 3 set bits.
 
Input Format:
-------------
Line-1: Two separated integers

Output Format:
--------------
Line-1: An integer

Sample Input-1:
---------------
6  10

Sample Output-1:
---------------
4

Explanation:
------------
6  -> 110 (2 set bits, 2 is prime)
7  -> 111 (3 set bits, 3 is prime)
8  -> 1000 (1 set bit, 1 is not prime)
9  -> 1001 (2 set bits, 2 is prime)
10 -> 1010 (2 set bits, 2 is prime)
4 numbers have a prime number of set bits.

Sample Input-2:
---------------
10 15

Sample Output-2:
---------------
5

Explanation:
------------
10 -> 1010 (2 set bits, 2 is prime)
11 -> 1011 (3 set bits, 3 is prime)
12 -> 1100 (2 set bits, 2 is prime)
13 -> 1101 (3 set bits, 3 is prime)
14 -> 1110 (3 set bits, 3 is prime)
15 -> 1111 (4 set bits, 4 is not prime)
5 numbers have a prime number of set bits.




Find the single non-repeated element in an array where every other element 
appears exactly twice.
The program should take the array size and elements as input from the user 
and print the element that occurs only once.

Example:
--------
Input:
-----
5
2 3 5 2 3

Output:
-------
5

(Key Property of XOR)
----------------------
a ^ a = 0
a ^ 0 = a
Duplicate elements cancel each other
Only the unique element remains


import java.util.*;
class SingleNonRepeatedElement{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int xor = 0;
        for(int i=0;i<n;i++){
            xor = xor^arr[i];
        }
        System.out.println(xor);
    }
}




Mr.Sathya is playing with numbers he converts the decimal to binary 
and try to find number of positions at which the corresponding
bits are different. 
Help sathya by giving solution to the problem 
to find sum of bits differences between all the pairs of the 
integers in given numbers.

Input Format:
--------------
Line-1: N, Number of integers
Line-2: N space separated list of integers

Output Format:
---------------
Line-1: A integer, Return the sum of bit differences between all the pairs of the integers.
 
Sample Input-1:
---------------
3
4 14 2

Sample Output-1: 
----------------
6

Explanation: 
------------
In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case).
The answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.

Sample Input-2: 
---------------- 
3
4 14 4

Sample Output-2: 
----------------
4


You are given an array called encoded, where each element is formed by 
taking the XOR of two consecutive elements of another hidden array arr.

You are also given the first element of the original array arr.
Your task is to reconstruct and print the original array.

Input Format:
------------------
n — the number of elements in the encoded array.
n space-separated integers — the elements of the encoded array.
first — the first element of the original array.

Output Format:
-----------------------
The decoded original array of size n + 1.

Sample Input 1:
-------------------
4
6 2 7 3
4

Sample Output 1:
-------------------
[4, 2, 0, 7, 4]


import java.util.*;
class Solution{
    public static void decode(int n,int[] arr,int firstEle){
        int k = firstEle;
        System.out.print(k+" ");
        for(int i=0;i<n;i++){
            k = k^arr[i];
            System.out.print(k+" ");
        }
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int firstEle = sc.nextInt();
        decode(n,arr,firstEle);
        
    }
}
