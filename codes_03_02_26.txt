CP_U2_AP32_OriginalArray

You are given an integer array pref of size n.
The array pref is created from another array arr using this rule:
pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]   (for i = 0 to n-1)

Here, ^ means bitwise XOR.

Your task is to find and return the original array arr.

Constraints:
---
1 <= pref.length <= 105
0 <= pref[i] <= 106

Input Format:
---
First line → integer n → the size of pref
Second line → n space-separated integers → elements of pref

Output Format:
---
Print the original array arr in array format (with brackets and commas)

Sample Input:
---
5
5 2 0 3 1

Sample Output:
---
[5, 7, 2, 3, 2]

Explanation:
---
arr[0] = pref[0] = 5
arr[1] = pref[0] ^ pref[1] = 5 ^ 2 = 7
arr[2] = pref[1] ^ pref[2] = 2 ^ 0 = 2
arr[3] = pref[2] ^ pref[3] = 0 ^ 3 = 3
arr[4] = pref[3] ^ pref[4] = 3 ^ 1 = 2
import java.util.*;
class Solution{
    public static void original(int n,int[] arr){
            System.out.print(arr[0]+" ");
            for(int i=0;i<n-1;i++){
                System.out.print((arr[i]^arr[i+1])+" ");
            }
 
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        original(n,arr);
 
    }
}


CP_U2_AP24_BinaryGap
Given a positive integer n, find and return the longest distance
between any two adjacent 1's in the binary representation of n.
 If there are no two adjacent 1's, return 0.
Two 1's are adjacent if there are only 0's separating them (possibly no 0's).
The distance between two 1's is the absolute difference between their bit
positions.
For example, the two 1's in "1001" have a distance of 3.
Example 1:
---
Input:  22
Output: 2
Explanation:
---
22 in binary is "10110".
The first adjacent pair of 1's is "10110" with a distance of 2.
The second adjacent pair of 1's is "10110" with a distance of 1.
The answer is the largest of these two distances, which is 2.
Note that "10110" is not a valid pair since there is a 1 separating the two 1's
underlined.
Example 2:
Input:  8
Output: 0

Explanation:
---
8 in binary is "1000".

There are not any adjacent pairs of 1's in the binary representation of 8, so
we return 0.
import java.util.*;
class BinaryGap{
    public static int gap(int n){
        int ind=0;
        int prevPos = -1;
        int maxLen = Integer.MIN_VALUE;
        while(n>0){
            if((n&1)==1){
                if(prevPos!=-1){
                    maxLen = Math.max(maxLen,Math.abs(prevPos-ind));
                }
                prevPos = ind;
            }
            ind++;
            n>>=1;
        }
        return maxLen;
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(gap(n));
    }
}


CP_U2_AP_GetSum
Given two integers a and b, return the sum of the two integers without using the operators +.

 
Example 1:
---
Input:
a = 1, b = 2
Output:
3

Example 2:b
---
Input:
a = -2, b = -3
Output:
-5
import java.util.*;
class GetSum{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        while(b!=0){
            int sum = a^b;
            int carry = ((a&b)<<1);
            a = sum;
            b = carry;
        }
        System.out.println(a);
    }
}



CP_U2_AP23_ImpossibleOr_Bit_Manipulation
You are given a 0-indexed integer array nums.

We say that an integer x is expressible from nums if there exist some integers
0 <= index1 < index2 < ... < indexk < nums.length for which
nums[index1] | nums[index2] | ... | nums[indexk] = x.
In other words, an integer is expressible if it can be written as the bitwise OR
of some subsequence of nums.

Return the minimum positive non-zero integer that is not expressible from nums.

Sample Input-1:
---
2
2 1

Sample Output-1:
---
4

Explanation:
---
1 and 2 are already present in the array. We know that 3 is expressible,
since nums[0] | nums[1] = 2 | 1 = 3.
Since 4 is not expressible, we return 4.

Sample Input-2:
---
3
5 3 2

Sample Output-2:
---
1

Explanation: We can show that 1 is the smallest number that is not expressible.
 

Constraints:
---
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9



CP_U2_AP26_Missing Number
In a classroom of students, each student has a unique identifier within the
range of [0, n]. However, one student has gone missing, and their absence needs
to be identified. Write a program that takes in an array of distinct student IDs
and returns the ID of the missing student.

input format:  an integer (n)
               n number of integers
output format: an integer

Example 1:

Input: nums = [3,0,1]
Output: 2
Explanation:
n = 3 since there are 3 numbers, so all numbers are in the range[0,3].
2 is the missing number in the range since it does not appear in nums.

Example 2:

Input: nums = [0,1]
Output: 2
Explanation:
n = 2 since there are 2 numbers, so all numbers are in the range [0,2].
2 is the missing number in the range since it does not appear in nums.

Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation:
n = 9 since there are 9 numbers, so all numbers are in the range [0,9].
8 is the missing number in the range since it does not appear in nums.
 
Constraints:
n == nums.length
1 <= n <= 10^4
0 <= nums[i] <= n
All the numbers of nums are unique.


import java.util.*;
class Solution{
    public static int missing(int n, int[] arr){
        int xor1 = 0;
        for(int i=0;i<=n;i++){
            xor1^=i;
        }
        int xor2 = 0;
        for(int i=0;i<n;i++){
            xor2^=arr[i];
        }
        return xor1^xor2;
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        System.out.println(missing(n,arr));
    }
}

CP_U2_AP30_MaxDistance
You are participating in a game.
You are given an integer number n, which represents n treasure chests arranged 
in a line.
The treasure chests are shown using the binary representation of the number:
1 → a treasure chest with gold
0 → an empty treasure chest
Your task is to find the longest distance between any two adjacent treasure 
chests that contain gold.

If there are no two treasure chests with gold, return 0 as the answer

Input Format:
--------------
A single integer n

Output Format:
---------------
A single integer
The longest distance between two adjacent treasure chests with gold

Example:
----------------------
If n = 22:
Binary representation of 22 is: 10110

Here:
The first two 1s are with a distance of 2
The Second two 1s are with a distance of 1
Highest Distance between them = 2
Hence 
Output is 2.