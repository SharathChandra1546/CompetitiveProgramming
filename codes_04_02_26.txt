/*
There is an integer array of N heights. You have to pick a certain number of 
heights from the array every time. Find the maximum  sum of all the heights 
picked every time that meets the following conditions:
    - The length of the subarray is L, and
    - All the heights of the subarray picked are distinct.

Return the maximum subarray sum of all the height subarrays that meet the 
conditions. If no heights subarray meets the conditions, return 0.

- A subarray is a contiguous non-empty sequence of elements within an array.

Input Format:
-------------
Line-1: Two space separated integers, N and L
Line-2: N space separated integers, height[].

Output Format:
--------------
Print an integer result.


Sample Input-1:
---------------
7 3
7 7 7 1 5 4 2

Sample Output-1:
----------------
13

Explanation: 
------------
The subarrays of length 3 of height array are:
    - [7,7,7] this subarray does not meet the requirement because 7 is repeated.
    - [7,7,1] this subarray does not meet the requirement because 7 is repeated.
    - [7,1,5] this subarray meets the requirements and its sum is 13.
    - [1,5,4] this subarray meets the requirements and its sum is 10.
    - [5,4,2] this subarray meets the requirements and its sum is 11. 

Return 13 because it is the maximum subarray sum of all the subarrays 
that meet the conditions


Sample Input-2:
---------------
3 3
7 7 7

Sample Output-2:
----------------
0

Explanation:
------------
The subarrays of length 3 of height array are:
- [7,7,7] which does not meet the requirements because the element 7 is repeated

Return 0 because no subarrays meet the conditions.
 */




import java.util.*;

class MaxOfAllSubarraysOfSizeK {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int window = sc.nextInt();
        int arr[] = new int[n];
        for(int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int res = maxSubarraySum(arr, n, window);
        System.out.println(res);
    }
    
    public static int maxSubarraySum(int arr[], int n, int w) {
        int maxSum = 0;
        int left = 0;
        int sum = 0;
        HashMap<Integer, Integer> hm = new HashMap<>();
        for(int right = 0; right < n; right++) {
            hm.put(arr[right], hm.getOrDefault(arr[right], 0) + 1);
            sum = sum + arr[right];
            while(hm.get(arr[right]) > 1 || (right - left + 1) > w) {
                hm.put(arr[left], hm.get(arr[left]) - 1);
                if(hm.get(arr[left]) <= 0) {
                    hm.remove(arr[left]);
                }
                sum = sum - arr[left];
                left++;
            }
            
            if((right - left + 1) == w) {
                maxSum = Math.max(maxSum, sum);
            }
        }
        return maxSum;
    }
}








/*
Given an integer array nums sorted in non-decreasing order, 
return an array of the squares of each number sorted in non-decreasing order.

Example 1:

Input:5
-4 -1 0 3 10
Output: [0, 1, 9, 16, 100]
*/



import java.util.*;

class SquaresofSortedArrays {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        ArrayList<Integer> res = sqOfSortArrays(arr, n);
        System.out.println(res);
    }

    public static ArrayList<Integer> sqOfSortArrays(int arr[], int n) {
        ArrayList<Integer> sq = new ArrayList<>();
        int left = 0, right = n - 1;
        while (left <= right) {
            int sqleft = arr[left] * arr[left];
            int sqright = arr[right] * arr[right];
            if (sqleft > sqright) {
                sq.add(sqleft);
                left++;
            } else {
                sq.add(sqright);
                right--;
            }
        }
        Collections.reverse(sq);
        return sq;
    }
}





/*
You are given a string s. We want to partition the string into 
as many parts as possible so that each letter appears in at most 
one part.

Note that the partition is done so that after concatenating 
all the parts in order, the resultant string should be s.

Return a list of integers representing the size of these parts. 

Example 1:
-----------
Input: ababcbacadefegdehijhklij
Output: [9, 7, 8]

Explanation:
-------------
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits 
s into less parts.

Example 2:
Input: eccbbbbdec
Output: [10]

Example 3:
Input: abacadcklmklmxyyzx
Output: [7, 6, 5]
*/





import java.util.*;

class PartitionLabels {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        List<Integer> result = partitionLabels(s);
        System.out.println(result);
    }

    public static List<Integer> partitionLabels(String s) {
        int[] last = new int[26];
        for (int i = 0; i < s.length(); i++) {
            last[s.charAt(i) - 'a'] = i;
        }
        List<Integer> res = new ArrayList<>();
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            end = Math.max(end, last[s.charAt(i) - 'a']);
            if (i == end) {
                res.add(end - start + 1);
                start = i + 1;
            }
        }
        return res;
    }
}


