FS_AP3_Maximum_Depth
Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the 
longest path from the root node down to the farthest leaf node.

Input Format:
--------------
Line-1: An integer n, the number of nodes (tokens) in the tree.
Line-2: n space-separated tokens representing the tree in level-order traversal 
        (use "null" for missing children).

Output Format:
---------------
Line-1: A single integer representing the maximum depth of the binary tree.


Constraints:
------------
*The number of nodes in the tree is in the range [0, 2000].
*-100 ≤ Node.val ≤ 100.

Sample Input-1:
---------------
7
3 9 20 null null 15 7

Sample Output-1:
-----------------
3

Sample Input-2:
---------------
1
1

Sample Output-2:
----------------
1

import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

public class Solution {
    // Build tree from level-order input with "null"
    private static TreeNode buildTree(String[] nodes) {
        if (nodes.length == 0 || nodes[0].equals("null")) return null;

        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        int i = 1;
        while (!queue.isEmpty() && i < nodes.length) {
            TreeNode current = queue.poll();

            if (i < nodes.length && !nodes[i].equals("null")) {
                current.left = new TreeNode(Integer.parseInt(nodes[i]));
                queue.add(current.left);
            }
            i++;

            if (i < nodes.length && !nodes[i].equals("null")) {
                current.right = new TreeNode(Integer.parseInt(nodes[i]));
                queue.add(current.right);
            }
            i++;
        }
        return root;
    }

    // Calculate max depth
    public static int maxDepth(TreeNode root) {
        //WRITE YOUR CODE HERE
        if(root == null) return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return 1+Math.max(left,right);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        sc.nextLine(); // consume newline
        String[] nodes = new String[n];
        if (n > 0) {
            nodes = sc.nextLine().split(" ");
        }

        TreeNode root = buildTree(nodes);
        System.out.println(maxDepth(root));
    }
}





FS_AP2_Zig_Zag
You are given the root of a binary tree.
Return the zigzag level order traversal of its nodes' values.
(That is, from left to right, then right to left for the next level, 
and alternate between.)

Input Format:
--------------
Line-1: An integer n, number of nodes in the tree.
Line-2: n space-separated integers representing the tree in level-order format 
        (use "null" for empty nodes).


Output Format:
---------------
Line-1: Print a list of lists, each representing a level in zigzag order.

Constraints:
------------
*The number of nodes in the tree is in the range [0, 2000].
*-100 ≤ Node.val ≤ 100.

Sample Input-1:
---------------
7
3 9 20 null null 15 7

Sample Output-1:
-----------------
[[3], [20, 9], [15, 7]]

Sample Input-2:
---------------
1
1


Sample Output-2:
----------------
[[1]]
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

public class Solution {

    // Build tree from level-order array with "null"
    private static TreeNode buildTree(String[] nodes) {
        if (nodes.length == 0 || nodes[0].equals("null")) return null;

        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        int i = 1;
        while (!queue.isEmpty() && i < nodes.length) {
            TreeNode current = queue.poll();

            if (i < nodes.length && !nodes[i].equals("null")) {
                current.left = new TreeNode(Integer.parseInt(nodes[i]));
                queue.add(current.left);
            }
            i++;

            if (i < nodes.length && !nodes[i].equals("null")) {
                current.right = new TreeNode(Integer.parseInt(nodes[i]));
                queue.add(current.right);
            }
            i++;
        }
        return root;
    }

    // Zigzag level order traversal
    public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        //WRITE YOUR CODE HERE AND RETURN LIST
        List<List<Integer>> list = new ArrayList<>();
        if(root== null) return list;
        Queue<TreeNode> q = new LinkedList<>();
        boolean rev = true;
        q.add(root);
        while(!q.isEmpty()){
            List<Integer> level = new ArrayList<>();
            int size = q.size();
            for(int i =0;i<size;i++){
                TreeNode curr = q.poll();
                if(rev){
                    level.add(curr.val);
                }
                else{
                    level.add(0,curr.val);
                }
                if(curr.left!=null) q.add(curr.left);
                if(curr.right!=null) q.add(curr.right);
            }
            list.add(level);
            rev = !rev;
        }
        return list;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Read input
        int n = sc.nextInt();
        sc.nextLine(); // consume newline
        String[] nodes = sc.nextLine().split(" ");

        TreeNode root = buildTree(nodes);

        List<List<Integer>> ans = zigzagLevelOrder(root);
        System.out.println(ans);
    }
}




FS_AP5_Distinct_Shapes
Viraj Aanand is a wedding planner, He ordered his assistant to decorate a wall.
The decorator plans to decorate the wall with two different colored balloons.
The wall size is M*N, The decorator can decorate the wall using M*N balloons
the balloons are blue or white in color.
Blue colored ballons represented with digit-1 and 
White colored ballons represented with digit-0.
The blue colored balloons forms different shapes, that are connected 4 directonally.
The directons are upwards, downwards, left, and right. Viraj Aanand got an idea to 
count the unique shapes formed by blue colored ballons.
You will be given the decorated wall as a matrix wall[][].
Your task is to help, Viraj Aanand to count the unique shapes.
Input Format:
Line-1: Two space separated integers M and N, size of the wall.
Next M lines: N space separated integers, either 0 or 1.

Output Format:
--------------
Print an integer, Number of distinct shapes formed by blue balloons.

Sample Input-1:
---------------
4 5
1 1 0 0 0
1 1 0 0 0
0 0 0 1 1
0 0 0 1 1
Sample Output-1:
----------------
1


Sample Input-2:
---------------
5 5
1 1 0 1 1
1 0 0 0 1
0 0 0 0 0
1 0 0 0 1
1 1 0 1 1

Sample Output-2:
----------------
4




FS_AP4_NumTilePossibilities
There are some cubes, each cube is printed with an alphabet [A-Z].
Using these cubes, you can create non-empty distinct words.
and length of the words should be 0< length <= no.of.cubes.

You are given a string of alphabets S, 
Your task is to findout number of possible non-empty distinct words

Input Format:
-------------
A string S, consist of A-Z letters only.

Output Format:
--------------
Print an integer, number of possible non-empty distinct words.


Sample Input-1:
---------------
EGG

Sample Output-1:
----------------
8

Explanation:
--------------
The possible distinct words are "E", "G", "EG", "GG", "GE", "EGG", "GEG", "GGE".


Sample Input-2:
---------------
MADAM

Sample Output-2:
----------------
89






