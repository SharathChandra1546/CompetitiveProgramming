
A tenth standard student has been given a task, Given P number of subject marks 
and a number I, He has to print the I-th least value of sums among all the 
possible sub-arrays of marks.

Input Format:
-------------
Line-1: Two space separated inetegers, P and I.
Line-2: P space separated integers, marks[].

Output Format:
--------------
Print the I-th least value of possible sums.

Sample Input-1:
--------------
3 4
3 2 4

Sample output-1:
---------------
5

Explanation: 
------------
The subarrays of 3 2 4 are:
1st subarray: 3 the sum is 3
2nd subarray: 2 the sum is 2
3rd subarray: 4 the sum is 4
4th subarray: 3,2 the sum is 5
5th subarray: 2,4 the sum is 6
6th subarray: 3,2,4 the sum is 9

The 4th smallest is 5

Sample Input-2:
---------------
4 7
2 2 4 4

Sample output-2:
----------------
8

Explanation: 
------------
The subarrays of 2 2 4 4 are

1st subarray: 2 the sum is 2
2nd subarray: 2 the sum is 2
3rd subarray: 4 the sum is 4
4th subarray: 4 the sum is 4
5th subarray: 2,2 the sum is 4
6th subarray: 2,4 the sum is 6
7th subarray: 4,4 the sum is 8
8th subarray: 2,2,4 the sum is 8
9th subarray: 2,4,4 the sum is 10
10th subarray: 2,2,4,4 the sum is 12

The 7th smallest is 8





You are given a 0-indexed string blocks of length n, 
where blocks[i] is either 'W' or 'B', representing the color of the ith block. 
The characters 'W' and 'B' denote the colors white and black, respectively.

You are also given an integer k, which is the desired number of consecutive 
black blocks.

In one operation, you can recolor a white block such that it becomes a black 
block.

Return the minimum number of operations needed such that there is at least one 
occurrence of k consecutive black blocks.

input format: string 
              an integer(k)
output format : an Integer

--------------------------- 
Example 1:
Input: WBBWWBBWBW
7
Output: 3
Explanation:
One way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 
4th blocks
so that blocks = "BBBBBBBWBW". 
It can be shown that there is no way to achieve 7 consecutive black blocks in 
less than 3 operations.
Therefore, we return 3.
-----------------------
Example 2:
Input:WBWBBBW
2
Output: 0
Explanation:
No changes need to be made, since 2 consecutive black blocks already exist.
Therefore, we return 0.
 
Constraints:
---------------------------
n == blocks.length
1 <= n <= 100
blocks[i] is either 'W' or 'B'.
1 <= k <= n

import java.util.*;
class Solution{
    public static int recolor(String s,int k){
        int countW =0;
        for(int i=0;i<k;i++){
            if(s.charAt(i) == 'W'||s.charAt(i)=='w'){
                countW++;
            }
        }
        int minW = countW;
        for(int i=k;i<s.length();i++){
            if(s.charAt(i) == 'W'||s.charAt(i)=='w'){
                countW++;
            }
            if(s.charAt(i - k) == 'W'){
                countW--;
            }
            minW = Math.min(minW,countW);   
        }
        return minW;
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        int k = sc.nextInt();
        System.out.println(recolor(s,k));
    }
}



Given a binary array, find the index of 0 to be replaced with 1 to get a 
maximum length sequence of continuous ones.

For example, consider array { 0, 0, 1, 0, 1, 1, 1, 0, 1, 1 }. 
The index to be replaced is 7 to get a continuous sequence of length 6 
containing all 1â€™s.

Note if no replacement is possible then print -1

Example:
input=10
0 0 1 0 1 1 1 0 1 1
output=7

Example 2:
input=12
1 1 1 1 1 1 1 1 1 1 1 0
output=11



A string is good if there are no repeated characters.
Given a string s, return the number of good substrings of length three in s.
Note that if there are multiple occurrences of the same substring, every 
occurrence should be counted.
A substring is a contiguous sequence of characters in a string.

Example 1:
input: s = "xyzzaz"
output: 1

Explanation: There are 4 substrings of size 3: "xyz", "yzz", "zza", and "zaz". 
The only good substring of length 3 is "xyz".

Example 2:
Input: s = "aababcabc"
Output: 4
Explanation: There are 7 substrings of size 3: "aab", "aba", "bab", "abc", 
"bca", "cab", and "abc".
The good substrings are "abc", "bca", "cab", and "abc".

import java.util.*;
class goodSubstrings{
    public static int good(String s){
        int n = s.length();
        int count =0,maxl=Integer.MIN_VALUE;
        HashMap<Character, Integer> map = new HashMap<>();
        for(int i=0;i<3;i++){
            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);
        }
        if(map.size()==3){
            count++;
        }
        maxl = count;
        for(int i=3;i<n;i++){
            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);
            if(map.get(s.charAt(i-3))==1){;
                map.remove(s.charAt(i-3));
            }
            else{
                map.put(s.charAt(i-3),map.get(s.charAt(i-3))-1);
            }
            if(map.size()==3){
                count++;
            }
            maxl = Math.max(count,maxl);
        }
        return maxl;
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        sc.nextLine();
        System.out.println(good(s));
    }
}




You are visiting a farm that has a single row of fruit trees arranged from left 
to right.
 The trees are represented by an integer array fruits where fruits[i] is the 
 type of fruit the ith tree produces.
You want to collect as much fruit as possible. 

However, the owner has some strict rules that you must follow:
You only have two baskets, and each basket can only hold a single type of fruit. 
There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from 
every tree (including the start tree)
 while moving to the right. The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits 
you can pick.

Sample cases:
-----------------------------
Sample input:
Input: 
3
1 2 1
Sample Output: 3
Explanation: We can pick from all 3 trees.
--------------------------------
Sample input:
Input: 
4
0 1 2 2 
Sample Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].
--------------------------------
Sample input:
5
1 2 3 2 2
Sample Output:4
Explanation: We can pick from trees [2,3,2,2].
If we had started at the first tree, we would only pick from trees [1,2].



