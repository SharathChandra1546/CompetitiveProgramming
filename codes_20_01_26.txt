You are given an array of integers.
Your task is to determine whether there exists any pair of two distinct elements
in the array whose sum equals a given target value.

If such a pair exists, print 1.
Otherwise, print 0.

Note:
------
You may not use the same element twice.
You need to sort the array.

Input Format:
-------------
Line-1: An integer N, representing the size of the array.
Line-2: N space-separated integers, representing the array elements.
Line-3: An integer X, representing the target sum.

Output Format:
-----------------
Print 1 if a pair exists whose sum equals X, otherwise print 0.

Constraints
1 ≤ N ≤ 10^5
-10^9 ≤ array[i] ≤ 10^9
-10^9 ≤ X ≤ 10^9

Sample Input:
-------------
4
1 4 2 5
7

Sample Output:
-------------
1

Explanation
------------
The numbers 2 and 5 form the sum 7.
Hence, a valid pair exists → output is 1.

import java.util.*;
class twoPointer{
    public static int pair(int[] arr, int sum){
        int left = 0;
        int right = arr.length-1;
        while(left<right){
            int currSum = arr[left]+arr[right];
            if(currSum>sum) right--;
            else if(currSum<sum) left++;
            else return 1;
        }
        return 0;
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr= new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int sum = sc.nextInt();
        Arrays.sort(arr);
        System.out.println(pair(arr,sum));
    }
}	



Given a string s, reverse only all the vowels in the 
string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can 
appear in both lower and upper cases, more than once.

Sample Input-1:
---------------
hello

Sample Output-1:
----------------
holle

Sample Input-2:
----------------
Keshavmemorial

Sample Output-2:
----------------
Kashivmomerael
import java.util.*;
class ReverseVowels{
    public static boolean isVowel(char c){
        return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='A'||c=='E'||c=='I'||c=='O'||c=='U';
    }
    public static String rev(char[] s){
        int left = 0;
        int right = s.length-1;
        while(left<right){
            if(!isVowel(s[left])){
                left++;
            }
            else if(!isVowel(s[right])){
                right--;
            }
            if(isVowel(s[left])&&isVowel(s[right])){
                char temp = s[left];
                s[left]= s[right];
                s[right] = temp;
                left++;
                right--;
            }
        }
        return new String(s);
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        System.out.println(rev(s.toCharArray()));
    }
}

You are given an array of integers nums of size N and a non-negative integer K.
Your task is to rotate the array to the right by K steps.
Each rotation shifts elements to the right, and the last element moves to the 
first position.

Input Format:
-------------
Line 1: An integer N, representing the size of the array.
Line 2: N space-separated integers, representing the elements of the array.
Line 3: An integer K, representing the number of right rotations.

Output Format:
--------------
Line-1: Print N space-separated integers representing the rotated array.

Sample Input-1:
---------------
7
1 2 3 4 5 6 7
4

Sample Output-1:
----------------
4 5 6 7 1 2 3

Explanation:
-------------
The array [1,2,3,4,5,6,7] is rotated 4 times to the right.
After 4 rotations: [4, 5, 6, 7, 1, 2, 3].

Sample Input-2:
---------------
5
10 20 30 40 50
2

Sample Output-2:
----------------
40 50 10 20 30

Explanation:
-------------
The array [10,20,30,40,50] is rotated 2 times to the right.
After 2 rotations: [40, 50, 10, 20, 30].

Sample Input-3:
---------------
6
5 15 25 35 45 55
0

Sample Output-3:
----------------
5 15 25 35 45 55

Explanation:
-------------
Since K = 0, the array remains unchanged.


import java.util.*;
class RotateArray{
    public static void rev(int[] arr, int start, int end){
        int left = start;
        int right = end;
        while(left<right){
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
    public static void rotate(int[] arr, int k){
        int n = arr.length;
        if(arr==null||arr.length<=1||k%arr.length==0) return;
        k=k%n;
        rev(arr,0,n-1);
        rev(arr,0,k-1);
        rev(arr,k,n-1);
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr= new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        int k = sc.nextInt();
        rotate(arr,k);
        for(int i =0;i<n;i++){
            System.out.print(arr[i]+" ");
        }
    }
}


Given an array nums with n objects colored red, white, or blue, 
sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function. 

Example 1:
input =
6
2 0 2 1 1 0
output =0 0 1 1 2 2


Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Example 2:

Input: nums = [2,0,1]
Output: [0,1,2]
 

Constraints:

n == nums.length
1 <= n <= 300
nums[i] is either 0, 1, or 2.




import java.util.*;
class SortColors{
    public static void swap(int arr[], int i,int j){
        if(i!=j){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j]  = temp;
        }
        
    }
    public static void sort(int n,int[] arr){
        int left = 0,right = n-1,curr = 0;
        while(curr<=right){
            if(arr[curr]==0){
                swap(arr, left, curr);
                curr++;
                left++;
            }
            else if(arr[curr]==2){
                swap(arr, right, curr);
                right--;
            }
            else if(arr[curr]==1){
                curr++;
            }
        }
        
    }
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr= new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        sort(n,arr);
        for(int i =0;i<n;i++){
            System.out.print(arr[i]+" ");
        }
    }
}





You are given a singly linked list containing N nodes. 
Your task is to find the middle element of the linked list.

Input Format:
-------------
Line 1: An integer N, representing the number of nodes in the linked list.
Line 2: N space-separated integers representing the elements of the linked list.

Output Format:
--------------
Line-1: Print a single integer, the middle element of the linked list.

Sample Input-1:
---------------
1 2 3 4 5                                                  

Sample Output-1:
----------------
3


Sample Input-2:
---------------
1 2 3 4 5 6

Sample Output-2:
----------------
4


import java.util.*;
class Node{
    int data;
    Node next;
    Node(int data){
        this.data = data;
        this.next = null;
    }
}
class LinkedList{
    public static Node head;
    public static void add(int data){
        Node newnode = new Node(data);
        if(head == null){
            head = newnode;
            return;
        }
        Node temp= head;
        while(temp.next!=null){
            temp = temp.next;
        }
        temp.next = newnode;
    }
    public static int mid(){
        Node slow = head;
        Node fast = head;
        while(fast.next!=null && fast.next.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow.data;
    }
}
public class MiddleElementLL{
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        String[] s = sc.nextLine().split(" ");
        LinkedList ll = new LinkedList();
        for(String x:s){
            ll.add(Integer.parseInt(x));
        }
        System.out.println(ll.mid());
    }
}


